# 作用域闭包

- 当函数能够"记住"并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

```
function foo () {
    var a = 2;
    function bar (){
        console.log(a)
    }
    return bar ;
}
var baz = foo()
baz () // 2  这里就是闭包的效果
```

- foo()执行后，其返回值（bar()函数）赋值给变量 baz 并调用 baz()，实际上是只通过不同标识符来引用 调用了内部函数 bar()
- 在 foo()执行后，通常会期待 foo()整个内部作用域被销毁，因为 js 引擎有垃圾回收器，用来释放不再使用的内存空间。由于 foo()的内容看上去不会再被使用，所以很自然的会考虑对它进行回收
- 而闭包阻止了 js 引擎的垃圾回收机制，foo()内部作用域依然存在，没有被回收，bar()本身在使用这个内部作用域。
- bar()对该作用域的引用，这个引用就叫闭包

闭包：函数在定义时的词法作用域外被调用，闭包使得函数可以继续访问定义时的词法作用域.

## 一个经典的新婚啊和闭包

```
for (var  i = 0; i <= 5; i++) {
console.log(i,'====')

    setTimeout(() => {
        console.log(i )
    }, i *1000);
}
``` 
这里会每隔1s打印1个6，而不是所期待的每隔1s 从0 打印到 5