# 块作用域

- with 关键字会创建一个块作用域，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效
- ES3 的 try/catch 的 catch 分局会创建一个块作用域，其声明的变量仅在 catch 内部有效

```
try(){
    undefined()
}catch(err){
    console.log(err) //能打印出err错误
}
console.log(err)// err not found
```

**但是当同一个作用域中两个或多个 catch 分局，用了同样的标识符声明错误变量，如都用了 catch(err) ，有些静态检查工具会发出警告，但实际上这不是重复定义**

- let 关键字可以将变量绑定到所在的任意作用域中，通常是{...}内部,也就是说 let 相当于为其声明的变量隐式劫持了所在的块作用域.
- 可以使用块作用域做一些垃圾回收，如上文调用的函数完毕后，可能还在占用内存

```
function foo(){...}
{
    let bar = {...}
    foo(bar) // 大括号为块级作用域，这里是显示声明作用域
}
```

- let 可以将 for 循环中声明的变量绑定到 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值、用 var 声明会造成该变量泄漏到上级作用域中

- const 同样可以来创建块级作用域变量，但值是固定的（常量）

## CON

- 块级作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常为{...}
- ES3 开始 ，try/catch 的 catch 分局中具有块级作用域
- ES6 引入的 let 能够隐式劫持作用域
